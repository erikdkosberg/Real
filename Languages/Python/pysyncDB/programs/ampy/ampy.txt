Okay, so here are our choices for imports.

I think we should bring both of them into play because they would allow us to have one method for working with data without the overhead of having to parse through everything. With the can framework, we are sniffing packets on the network and passing them through a Parser to determine their meaning. One advantage of doing it this way is that we can directly write back to memory at the address of a desired packet if we really wanted to.

ampy consists of several modules:
	connect.py
	command.py
	key_names.py
	sniffer.py
	GUI.py
	log.py

#----------------Connect-----------------#

#connect.py

import obd

class Connection(self, device, port, **kwargs):
	def __init__(self):
		self.name = "Connection String"
	def activate(self):	
		connection = obd.OBD("/dev/tty")
		ports = obd.scan_serial()
		connection = obd.OBD(ports[0])
	def close(self):
		connection.close()


#----------------Command-----------------#

#command.py
n = lambda : print('n')

def command_line_arguments():
	print("Command Line Arguments"
	n()
	print("READ-ONLY")
	print("-d -devices : list of all available devices")
	print("-p -ports : list of all available ports")
	print"EXECUTABLES")
	print"d-p : connect a device to a port")

def usage():
	print("Welcome to AMPY...")
	n()
	print("To see a list of all available devices : ampy -d")
	print("To see a list of all available ports : ampy -p
	print("For all command-line arguments, please type : ampy -help")
	print("To connect a device to a port : ampy d-p")
	n()
	n()

def main():
	usage()

if __name__ == "__main__":
	main()

#--------------Key_Names-----------------#

#key_names.py

PIDS = {
	"Engine RPM" : 123,
	"Mass Air Flow" : 456,
	"Barometric Pressure Sensor" : 789
	}

MODES = [
	"01", #read
	"02", #write
	"03" #log
	]

FLAGS = 0

#--------------Sniffer----------------#

#sniffer.py

'''

	Create a sniffed object based on a given network.

	This class also holds several methods giving the developer better access to the data, useful for debugging
	All sniffed packets are read in in a predefined type:
		Current Static - ' a freeze frame of whenever the read value was executed '
		Current Dynamic - ' feedback on a loop updating after consistent intervals '
		Most Recent - ' the last sniffed object still in buffer ' 

import Penguin

#packet-type for static, dynamic and recent, respectively; used as placeholder when initializing

PACKET_TYPE = [0, 0, 0]

Class Conversions(**ascii, **hex, **binary):
	def ascii_to_hex:
		pass

	def hex_to_ascii(hex_string):
		#remove leading '0x'
		bytes_object = bytes.fromhex(hex_string[2:])
		return bytes_object.decode("ASCII")

	def binary_to_hex:
		pass
	def ascii_to_binary:
		pass
	def hex_to_binary:
		pass
	def binary_to_ascii:
		pass

Class Sniffer(self, key):
	def __init__(self):
		self.name = "Sniff String"
		print("...looking for packets")
	def search_by_id(key, iterable):
		z = [x for key in iterable if key == x]
		return z
	def output_to_txt(data, file):
		file.append(data)
	def file_handler(file):
		handle = Penguin.Parser(file)
	def clear_buffer():
		pass
		


#---------------GUI--------------------#

#GUI.py

import tkinter

#--------------Log----------------#

#log.py

"""

this snippet was taken from socketCAN website - used for Wireshark debugging



"""

import time
import can

bustype = 'socketcan'
channel = 'vcan0'

def producer(id):
    """:param id: Spam the bus with messages including the data id."""
    bus = can.interface.Bus(channel=channel, bustype=bustype)
    for i in range(10):
        msg = can.Message(arbitration_id=0xc0ffee, data=[id, i, 0, 1, 3, 1, 4, 1], is_extended_id=False)
        bus.send(msg)

    time.sleep(1)

producer(10)



#The Difference between Connections : PythonOBD vs SocketCAN


obd - PyOBD - Python OBD

	connection = obd.OBD("/dev/tty")
	ports = obd.scan_serial()
	connection = obd.OBD(ports[0])

can - SocketCAN - PythonCAN

	"""
					run from Linux terminal;
	"""

	#modprobe inserts a module into the kernel; vcan is virtual CAN network interface that allows us to see what's on that network

	sudo modprobe vcan

	#link to manage and view the state of network interfaces; add a new device vcan0
	
	sudo ip link add dev vcan0 type vcan

	#bring it online

	sudo ip link set vcan0 up

